---
title: Devicon Lookup - Binary Search Experiment
author: Corey Alexander
date: 2019-02-03
tags:
  - devicons
  - rust
  - binary-search
  - cache
color: red
---

## Background

Recently I wrote, and [blogged about](), writing the [`devicon-lookup`]() tool. Which is intended to be used in VIM and fzf to provide icons for the corresponding file types. It got posted to the Rust sub-reddit, and got a few comments. I chatted a bit with one commenter about some possible speed improvements, and he mentioned that he might use a sorted list, and do a binary search for the lookup instead of taking the time to build a HashMap.

I decided to give this a shot, and this is a blog post explaining what I did, and the results I found!

## Existing Implementation

The existing implementation available, used the Rust crate `lazy_static` to create a static at runtime HashMap, which the program then used to perform the look ups from file extension to devicon symbol.

## Experiments

### Binary Search

A binary search is an efficient way of searching through a sorted list for a specific value. The first step was to take the initialization of HashMap and turn it into a sorted Array. Since I had already sorted the HashMap insertions for code cleanliness, this was as simple as changing the hash to an array of tuples. Where the first element in the tuple was the extension and the second value was the symbol.

```rust
const SYMBOLS: [(&str, &str); 97] = [
  ("ai", ""),
  ...
  ("zsh", ""),
  ];
```

Then I used the Rust collection method `binary_search_by_key` which allows you to pass in both the value you are searching for and a lambda that specifies how to retrieve the `key` to use for the binary search from the underlying objects. The lambda that I supplied simply returned the extension value from the tuple.

```rust
  let index = SYMBOLS.binary_search_by_key(&extension, |&(ext, _sym)| ext);
```

#### Results

Gonna have two sections of these results. One of the Chromebook where I did most of the development for this, and one on my Macbook Pro Laptop for a comparison of my day-to-day workstation.

In all of the results I start by preparing a large file `~/tmp/large.txt` that will contain a large set of examples. This set WILL be consistent across machines, in an attempt to make them more comparable. The file was generated by listing the files in home directory of my Chromebook, and will not be published for privacy reasons.

All time testing was done with [Hyperfine]()

##### Chromebook Results

A run of `cat ~/tmp/large.txt | devicon-lookup` as a baseline took on average `3.852 s` with a STD deviation of `0.125 s`

A run of `cat ~/tmp/large.txt | ./target/release/devicon-lookup` took on average `3.910 s` with a STD deviation of `0.119 s`


##### Macbook Pro Results

ADD RESULTS HERE

### Binary Search with HashMap cache

The results from the standard Binary Search weren't much better, if at all better than the original implementation. So I wanted to see if adding a HashMap, cache would help. The idea being that you would build up the HashMap, slowly as you found the symbols you needed. This would in theory avoid the upfront initialization cost of creating the HashMap.

This part took me awhile to work out correctly, and this was mostly due to fighting with Rust's borrow checker. There was two major things that helped me get over some hurdles.
The thing that helped me over my first hurdle was this Rust Lang forum answer that helped me figure out how to use a HashMap as a cache as it relates to ownership. This example gave me a great place to start, especially related to the usages of `to_owned()`. https://users.rust-lang.org/t/borrow-checker-stopping-update-to-hashmap-cache/5300/3

The second was realizing that I probably wanted the cache HashMap to be `<String,String>` instead of the `<&str,&str>` that it was before. Previously I was using the reference type because before all the strings I was dealing with in the HashMap were static. Once I made this change I was able to get my code to compile much easier.

This is the current state of the code that lives on the `binary-seach` branch on [GitHub](https://github.com/coreyja/devicon-lookup/tree/binary-search)

#### Results

##### Chromebook Results

A run of `cat ~/tmp/large.txt | ./target/release/devicon-lookup` took on average `3.976 s` with a STD deviation of `0.070 s`

## Next Steps

This was a fun experiment, and I learned a lot about the Rust ownership model and the borrow checker! However the results to not seem to show any performance improvements, and actually show regressions in most tests. Do to this reason, and the added code complexity, I do not think I will merge by `binary-search` branch.
